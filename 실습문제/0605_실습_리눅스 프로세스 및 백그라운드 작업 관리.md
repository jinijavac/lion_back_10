### 실습 : 리눅스 프로세스 및 백그라운드 작업 관리

#### 시나리오 개요
이번 실습에서는 리눅스 터미널에서 프로세스를 관리하는 방법과 백그라운드 작업을 다루는 방법을 배웁니다. 특히, 포그라운드와 백그라운드에서 작업을 실행하고 전환하는 방법, 프로세스를 모니터링하고 종료하는 방법, `nohup`을 사용하여 터미널 세션 종료 후에도 계속 실행되는 작업을 설정하는 방법을 실습합니다.

### 실습 1: 포그라운드와 백그라운드 작업

1. **포그라운드에서 작업 실행**
    - 터미널을 열고 `sleep 60` 명령어를 실행하여 60초 동안 터미널을 점유하는 작업을 시작합니다.
      ```bash
      sleep 60
      ```
    - 작업이 완료될 때까지 터미널에서 다른 명령어를 실행할 수 없음을 확인합니다.

2. **백그라운드에서 작업 실행**
    - `sleep 60` 명령어를 백그라운드에서 실행하여 터미널을 점유하지 않도록 합니다.
      ```bash
      sleep 60 &
      ```
    - `jobs` 명령어를 사용하여 백그라운드 작업 목록을 확인합니다.
      ```bash
      jobs
      ```

3. **포그라운드 작업을 백그라운드로 전환**
    - `sleep 60` 명령어를 실행하여 포그라운드 작업을 시작합니다.
      ```bash
      sleep 60
      ```
    - `Ctrl + Z`를 눌러 작업을 일시 중지합니다.
    - `bg` 명령어를 사용하여 작업을 백그라운드로 전환합니다.
      ```bash
      bg
      ```

4. **백그라운드 작업을 포그라운드로 전환**
    - `jobs` 명령어를 사용하여 백그라운드 작업 목록을 확인합니다.
      ```bash
      jobs
      ```
    - `fg %1` 명령어를 사용하여 작업 번호 1인 백그라운드 작업을 포그라운드로 전환합니다.
      ```bash
      fg %1
      ```

### 실습 2: 프로세스 관리

1. **프로세스 목록 확인**
    - `ps aux` 명령어를 사용하여 현재 실행 중인 모든 프로세스를 나열합니다.
      ```bash
      ps aux
      ```

2. **특정 프로세스 검색**
    - `ps aux | grep sleep` 명령어를 사용하여 `sleep` 프로세스를 검색합니다.
      ```bash
      ps aux | grep sleep
      ```

3. **프로세스 종료**
    - `sleep` 프로세스의 PID를 확인한 후 `kill` 명령어를 사용하여 해당 프로세스를 종료합니다.
      ```bash
      kill <PID>
      ```
    - 프로세스가 종료되지 않는 경우 `kill -9 <PID>` 명령어를 사용하여 강제로 종료합니다.
      ```bash
      kill -9 <PID>
      ```

### 실습 3: nohup과 출력 리디렉션

1. **nohup으로 작업 실행**
    - `nohup sleep 60 &` 명령어를 사용하여 `sleep 60` 작업을 백그라운드에서 실행하고 터미널 세션 종료 후에도 계속 실행되도록 합니다.
      ```bash
      nohup sleep 60 &
      ```

2. **출력 리디렉션**
    - `nohup` 명령어의 출력을 특정 파일로 리디렉션하여 실행합니다.
      ```bash
      nohup sleep 60 > sleep_output.log 2>&1 &
      ```

3. **nohup으로 스프링 부트 애플리케이션 실행**
    - `apidemo-0.0.1-SNAPSHOT.jar` 파일을 백그라운드에서 실행하고 로그를 `app.log` 파일에 저장합니다.
      ```bash
      nohup java -jar apidemo-0.0.1-SNAPSHOT.jar > app.log 2>&1 &
      ```

4. **프로세스 확인**
    - 터미널을 종료한 후 다시 접속하여 프로세스를 확인합니다.
      ```bash
      ps -elf | grep java
      ```

### 실습 4: 표준 스트림 및 리디렉션

1. **표준 출력 리디렉션**
    - `ls` 명령어의 출력을 `ls_output.txt` 파일로 리디렉션합니다.
      ```bash
      ls > ls_output.txt
      ```

2. **표준 오류 리디렉션**
    - 존재하지 않는 파일을 리스트하여 오류 출력을 `error.log` 파일에 리디렉션합니다.
      ```bash
      ls nonexistent_file 2> error.log
      ```

3. **표준 출력과 표준 오류를 동시에 리디렉션**
    - `command > output.log 2>&1` 명령어를 사용하여 표준 출력과 표준 오류를 `output.log` 파일에 리디렉션합니다.
      ```bash
      command > output.log 2>&1
      ```

### 실습 5: 파이프와 명령어 조합

1. **디스크 사용량 확인**
    - `df -h` 명령어의 출력을 `grep` 명령어와 조합하여 `/dev/sda1` 파일 시스템 정보를 검색합니다.
      ```bash
      df -h | grep '/dev/sda1'
      ```

2. **네트워크 인터페이스 정보 확인**
    - `ifconfig` 명령어의 출력을 `grep` 명령어와 조합하여 `inet`으로 시작하는 줄을 검색합니다.
      ```bash
      ifconfig | grep 'inet '
      ```

3. **로그 파일에서 특정 키워드 검색**
    - `/var/log/syslog` 파일에서 `error` 키워드가 포함된 줄을 검색합니다.
      ```bash
      cat /var/log/syslog | grep 'error'
      ```

4. **특정 사용자 프로세스 검색**
    - `ps -ef` 명령어의 출력을 `grep` 명령어와 조합하여 `username` 사용자의 프로세스를 검색합니다.
      ```bash
      ps -ef | grep 'username'
      ```
